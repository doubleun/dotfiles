{"id":"3d24b5ce-b379-4042-8c95-1a881f223242","zed":"context","version":"0.4.0","text":"\n\n```ts ssch-backend/packages/products/src/repositories/product/Product.repository.ts\nimport {\n  Prisma,\n  PrismaClient,\n  ProductPicture,\n  ProductVideo,\n} from '@prisma/client/products'\n\nimport {\n  CreateProductWithCustomFieldInput,\n  GetProductsTRPCInput,\n  ToggleProductActiveStatus,\n  ToggleProductSearchableStatus,\n  UpdateProductWithCustomFieldInput,\n} from '../../models/v2/product.model'\n\nclass ProductRepository {\n  private prisma: PrismaClient\n  constructor(_prisma: PrismaClient) {\n    this.prisma = _prisma\n  }\n\n  async createProductWithCustomFields(\n    createProductWithCustomFieldInput: Omit<\n      CreateProductWithCustomFieldInput,\n      | 'pictures'\n      | 'videos'\n      | 'auxiliaryLabel'\n      | 'productForms'\n      | 'skinTypes'\n      | 'concerns'\n      | 'attribute'\n    > & {\n      pictures: Pick<ProductPicture, 'rank' | 'url'>[]\n      videos: Pick<ProductVideo, 'rank' | 'url' | 'thumbnail'>[]\n    },\n  ) {\n    const { categoryId, customFieldIds, pictures, videos, ...productDetail } =\n      createProductWithCustomFieldInput\n\n    return this.prisma.product.create({\n      data: {\n        ...productDetail,\n        descriptionTr: {\n          en: productDetail.descriptionTr?.en,\n          th: productDetail.descriptionTr?.en,\n        },\n        instructionTr: {\n          en: productDetail.instructionTr?.th,\n          th: productDetail.instructionTr?.en,\n        },\n        sideEffectTr: {\n          en: productDetail.sideEffectTr?.th,\n          th: productDetail.sideEffectTr?.en,\n        },\n        cautionTr: {\n          en: productDetail.cautionTr?.th,\n          th: productDetail.cautionTr?.en,\n        },\n        propertyTr: {\n          en: productDetail.propertyTr?.th,\n          th: productDetail.propertyTr?.en,\n        },\n        genericTr: {\n          en: productDetail.genericTr?.th,\n          th: productDetail.genericTr?.en,\n        },\n        categories: {\n          createMany: {\n            data:\n              categoryId?.map((id) => ({\n                categoryId: id,\n              })) ?? [],\n          },\n        },\n        productOnCustomField: {\n          create: customFieldIds.map((fieldId) => ({ fieldId })),\n        },\n        pictures: {\n          createMany: {\n            data: pictures,\n          },\n        },\n        video: {\n          createMany: {\n            data: videos,\n          },\n        },\n      },\n      include: {\n        productOnCustomField: { include: { field: true } },\n        categories: { include: { category: true } },\n        brand: true,\n        variants: true,\n        pictures: true,\n        video: true,\n      },\n    })\n  }\n\n  async updateProductWithCustomFields(\n    productId: number,\n    updateProductWithCustomFieldInput: Omit<\n      UpdateProductWithCustomFieldInput,\n      | 'productId'\n      | 'pictures'\n      | 'videos'\n      | 'auxiliaryLabel'\n      | 'productForms'\n      | 'skinTypes'\n      | 'concerns'\n      | 'attribute'\n    > & {\n      pictures: Pick<ProductPicture, 'rank' | 'url'>[]\n      videos: Pick<ProductVideo, 'rank' | 'url' | 'thumbnail'>[]\n    },\n  ) {\n    const { categoryId, customFieldIds, pictures, videos, ...productDetail } =\n      updateProductWithCustomFieldInput\n\n    const categories = categoryId?.length\n      ? {\n          deleteMany: { productId },\n          createMany: {\n            data: categoryId.map((id) => ({ categoryId: id })),\n            skipDuplicates: true,\n          },\n        }\n      : undefined\n    const productOnCustomField = customFieldIds?.length\n      ? {\n          deleteMany: { productId },\n          create: customFieldIds.map((fieldId) => ({ fieldId })),\n        }\n      : undefined\n    const productPictures = pictures?.length\n      ? { deleteMany: { productId }, createMany: { data: pictures } }\n      : undefined\n    const productVideos = videos?.length\n      ? {\n          deleteMany: { productId },\n          createMany: { data: videos },\n        }\n      : undefined\n\n    return this.prisma.product.update({\n      where: { id: productId },\n      data: {\n        ...productDetail,\n        categories,\n        productOnCustomField,\n        pictures: productPictures,\n        video: productVideos,\n      },\n      include: {\n        productOnCustomField: { include: { field: true } },\n        categories: { include: { category: true } },\n        brand: true,\n        variants: true,\n        pictures: true,\n        video: true,\n      },\n    })\n  }\n\n  async getProductWithCustomFields(productId: number) {\n    return this.prisma.product.findUnique({\n      where: { id: productId },\n      include: {\n        productOnCustomField: { include: { field: true } },\n        categories: { include: { category: true } },\n        brand: true,\n        variants: true,\n        pictures: true,\n        video: true,\n      },\n    })\n  }\n\n  async getProducts<I extends Prisma.ProductInclude>({\n    page,\n    limit,\n    orderBy: orderKey,\n    orderDirection,\n    product,\n    productId,\n    brandId,\n    categoryId,\n    type,\n    drugGroup,\n    genericName,\n    productForms,\n    include,\n  }: GetProductsTRPCInput & {\n    include?: I\n  }) {\n    const isFilterByProductForms = Boolean(productForms?.length)\n    const productOnCustomField = isFilterByProductForms\n      ? ({\n          some: {\n            fieldId: {\n              in: productForms,\n            },\n          },\n        } as const)\n      : undefined\n    const isFilterByCategories = Boolean(categoryId?.length)\n    const categories = isFilterByCategories\n      ? ({\n          some: {\n            categoryId: { in: categoryId },\n          },\n        } as const)\n      : undefined\n    const orderBy = orderKey ? { [orderKey]: orderDirection } : undefined\n\n    const where: Prisma.ProductWhereInput = {\n      AND: [\n        { id: productId },\n        { searchField: { contains: product } },\n        { brandId },\n        { type },\n        { productOnCustomField },\n        { drugGroup },\n        { genericSearch: { contains: genericName } },\n        { categories },\n      ],\n    }\n\n    const [products, count] = (await Promise.all([\n      this.prisma.product.findMany({\n        skip: (page - 1) * limit,\n        take: limit,\n        orderBy,\n        where,\n        include,\n      }),\n      this.prisma.product.count({ where }),\n    ])) as [Prisma.ProductGetPayload<{ include: I }>[], number]\n\n    return {\n      products,\n      count,\n    }\n  }\n\n  async updateProductPicturesAndVideos(\n    productId: number,\n    updateProductPicturesAndVideosInput: {\n      pictures: Pick<ProductPicture, 'rank' | 'url'>[]\n      videos: Pick<ProductVideo, 'rank' | 'url' | 'thumbnail'>[]\n    },\n  ) {\n    const { pictures, videos } = updateProductPicturesAndVideosInput\n\n    const productPictures = pictures?.length\n      ? { deleteMany: { productId }, createMany: { data: pictures } }\n      : undefined\n    const productVideos = videos?.length\n      ? {\n          deleteMany: { productId },\n          createMany: { data: videos },\n        }\n      : undefined\n\n    return this.prisma.product.update({\n      where: { id: productId },\n      data: {\n        pictures: productPictures,\n        video: productVideos,\n      },\n      include: {\n        productOnCustomField: { include: { field: true } },\n        categories: { include: { category: true } },\n        brand: true,\n        variants: true,\n        pictures: true,\n        video: true,\n      },\n    })\n  }\n\n  async getProductById(productId: number) {\n    return this.prisma.product.findUnique({\n      where: { id: productId },\n    })\n  }\n\n  async getProductWithVaraintsById(productId: number) {\n    return this.prisma.product.findUnique({\n      where: { id: productId },\n      include: { variants: true },\n    })\n  }\n\n  async setActive({ productId, active }: ToggleProductActiveStatus) {\n    return this.prisma.product.update({\n      where: { id: productId },\n      data: {\n        active,\n      },\n    })\n  }\n\n  async setSearchable({\n    productId,\n    searchable,\n  }: ToggleProductSearchableStatus) {\n    return this.prisma.product.update({\n      where: { id: productId },\n      data: {\n        searchable,\n      },\n    })\n  }\n}\n\nexport default ProductRepository\n```\n\n```ts ssch-backend/packages/products/src/service/__test__/product/Product.service.spec.ts\nimport { ProductPublisher } from '../../../pubsub/product'\nimport ProductRepository from '../../../repositories/product/Product.repository'\nimport { fileService } from '../../../services/file.service'\nimport ProductService from '../../product/Product.service'\n\n\njest.mock('../../services/file.service')\njest.mock('../../pubsub/product')\njest.mock('../../repositories/product/Product.repository')\n\ndescribe('ProductService', () => {\nlet productService: ProductService\nlet productRepository: jest.Mocked<ProductRepository>\n\n  beforeEach(() => {\n  jest.clearAllMocks()\n  \n    // Create a new instance of ProductRepository with mocked methods\n    productRepository = {\n    createProductWithCustomFields: jest.fn(),\n    updateProductPicturesAndVideos: jest.fn(),\n    getProductWithCustomFields: jest.fn(),\n    updateProductWithCustomFields: jest.fn(),\n    getProductWithVaraintsById: jest.fn(),\n    getProductById: jest.fn(),\n    setActive: jest.fn(),\n    setSearchable: jest.fn(),\n    getProducts: jest.fn(),\n    } as unknown as jest.Mocked<ProductRepository>\n    \n    productService = new ProductService(productRepository)\n    })\n    \n  describe('createProductWithCustomFields', () => {\n  const mockProductInput = {\n  nameTr: { en: 'Test Product' },\n  brandId: 1,\n  pictures: [{ gsPath: 'test/path/image.jpg' }],\n  videos: [{ gsPath: 'test/path/video.mp4', thumbnailGsPath: 'test/path/thumb.jpg' }]\n  }\n  const mockCreatedProduct = {\n  id: 1,\n  nameTr: { en: 'Test Product' },\n  brandId: 1,\n  pictures: [{ rank: 1, url: 'test/path/image.jpg' }],\n  video: [{ rank: 1, url: 'test/path/video.mp4', thumbnail: 'test/path/thumb.jpg' }]\n  }\n  \n    it('should create a product with media successfully', async () => {\n    // Mock file checks\n    (fileService.checkFileExist as jest.Mock).mockResolvedValue(true)\n    \n         // Mock repository calls\n         productRepository.createProductWithCustomFields.mockResolvedValue(mockCreatedProduct)\n         productRepository.updateProductPicturesAndVideos.mockResolvedValue(mockCreatedProduct)\n         \n         const result = await productService.createProductWithCustomFields(mockProductInput)\n         \n         expect(result).toBeDefined()\n         expect(result.nameTr).toEqual(mockProductInput.nameTr)\n         expect(ProductPublisher.createProducts).toHaveBeenCalledWith([1])\n         })\n         \n  })\n  })\n  ```\n  \nhelp me mock resolved value of `createProductWithCustomFields`\nBased on the repository implementation, I'll help you create a more detailed mock response for `createProductWithCustomFields`. Here's how you can structure it:\n\n```typescript\nconst mockCreatedProduct = {\n  id: 1,\n  nameTr: { en: 'Test Product' },\n  brandId: 1,\n  pictures: [\n    { \n      rank: 1, \n      url: 'test/path/image.jpg',\n      productId: 1,\n    }\n  ],\n  video: [\n    { \n      rank: 1, \n      url: 'test/path/video.mp4', \n      thumbnail: 'test/path/thumb.jpg',\n      productId: 1,\n    }\n  ],\n  // Additional fields from the repository response\n  productOnCustomField: [\n    {\n      field: {\n        id: 1,\n        name: 'Test Field'\n        // Add other field properties as needed\n      }\n    }\n  ],\n  categories: [\n    {\n      category: {\n        id: 1,\n        name: 'Test Category'\n        // Add other category properties as needed\n      }\n    }\n  ],\n  brand: {\n    id: 1,\n    name: 'Test Brand'\n    // Add other brand properties as needed\n  },\n  variants: [\n    {\n      id: 1,\n      name: 'Test Variant'\n      // Add other variant properties as needed\n    }\n  ],\n  // Add other required product fields\n  descriptionTr: { en: 'Description', th: 'Description' },\n  instructionTr: { en: 'Instruction', th: 'Instruction' },\n  sideEffectTr: { en: 'Side Effect', th: 'Side Effect' },\n  cautionTr: { en: 'Caution', th: 'Caution' },\n  propertyTr: { en: 'Property', th: 'Property' },\n  genericTr: { en: 'Generic', th: 'Generic' },\n}\n```\n\nThen in your test:\n\n```typescript\ndescribe('createProductWithCustomFields', () => {\n  const mockProductInput = {\n    nameTr: { en: 'Test Product' },\n    brandId: 1,\n    pictures: [{ gsPath: 'test/path/image.jpg' }],\n    videos: [{ gsPath: 'test/path/video.mp4', thumbnailGsPath: 'test/path/thumb.jpg' }]\n  }\n\n  it('should create a product with media successfully', async () => {\n    // Mock file checks\n    (fileService.checkFileExist as jest.Mock).mockResolvedValue(true)\n    \n    // Mock repository calls\n    productRepository.createProductWithCustomFields.mockResolvedValue(mockCreatedProduct)\n    productRepository.updateProductPicturesAndVideos.mockResolvedValue(mockCreatedProduct)\n    \n    const result = await productService.createProductWithCustomFields(mockProductInput)\n    \n    expect(result).toBeDefined()\n    expect(result.nameTr).toEqual(mockProductInput.nameTr)\n    expect(ProductPublisher.createProducts).toHaveBeenCalledWith([1])\n  })\n})\n```\n\nThis mock response matches the structure that would be returned by the repository's `createProductWithCustomFields` method, including all the relations that are included in the Prisma query (`productOnCustomField`, `categories`, `brand`, `variants`, `pictures`, and `video`).\n\nRemember to adjust the mock data according to your specific needs and the actual data structure you're working with. You might need to add or modify fields based on your actual implementation and test requirements.\nHelp me generate a mock input object of `createProductWithCustomFields` function\n```ts ssch-backend/packages/products/src/service/product/Product.service.ts\nimport { Product, ProductPicture, ProductVideo } from '@prisma/client/products'\nimport { TrField, TrFieldOptional } from '@ssch-backend/share-model'\nimport { getMovePath } from '@ssch-backend/utils/storage-util'\nimport { TRPCError } from '@trpc/server'\nimport difference from 'lodash.difference'\nimport omit from 'lodash.omit'\n\nimport * as mime from 'mime-types'\nimport path from 'path'\nimport { v4 as uuidv4 } from 'uuid'\nimport {\n    GenerateUploadProductMediaInput,\n    GetProductResponse,\n    GetProductsTRPCInput,\n    GetProductWithBrandAndCategoriesResponse,\n    ProductPicture as ProductPictureInput,\n    ProductVideo as ProductVideoInput,\n    ProductWithBrandAndCategoriesResponse,\n    ProductWithCustomFieldInputUnion,\n    ProductWithCustomFieldResponse,\n    ToggleProductActiveStatus,\n    ToggleProductSearchableStatus,\n    UpdateProductWithCustomFieldInputUnion\n} from '../../models/v2/product.model'\nimport { ProductPublisher } from '../../pubsub/product'\nimport ProductRepository from '../../repositories/product/Product.repository'\nimport { fileService } from '../../services/file.service'\n\nclass ProductService {\n  private productRepository: ProductRepository\n  constructor(_productRepository: ProductRepository) {\n    this.productRepository = _productRepository\n  }\n\n  private manageProductMediaChanges(\n    product: Product & {\n      pictures: ProductPicture[]\n      video: ProductVideo[]\n    },\n    mediaTransformation: {\n      transformProductPictures: Pick<ProductPicture, 'rank' | 'url'>[]\n      transformProductVideos: Pick<ProductVideo, 'rank' | 'url' | 'thumbnail'>[]\n    },\n  ) {\n    return {\n      pictures: this.managePictureChanges(\n        product.id,\n        product.pictures,\n        mediaTransformation.transformProductPictures,\n      ),\n      videos: this.manageVideoChanges(\n        product.id,\n        product.video,\n        mediaTransformation.transformProductVideos,\n      ),\n    }\n  }\n\n  private managePictureChanges(\n    productId: number,\n    oldPictures: ProductPicture[],\n    newPictures?: Pick<ProductPicture, 'rank' | 'url'>[],\n  ) {\n    const oldPictureUrls = oldPictures?.map((pic) => pic.url) ?? []\n    const newPictureUrls = newPictures?.map((pic) => pic.url) ?? []\n\n    const toDeletePictures = difference(oldPictureUrls, newPictureUrls)\n    const toCreateNewPicturesData: Pick<ProductPicture, 'rank' | 'url'>[] = []\n    const movePaths: { from: string; to: string }[] = []\n    const setHolds: string[] = []\n    const unsetHolds: string[] = toDeletePictures.filter(Boolean)\n\n    newPictures?.forEach((pic, index) => {\n      if (!pic?.url) return\n\n      const to = !oldPictureUrls.includes(pic.url)\n        ? getMovePath(pic.url, `product/product/${productId}/pictures`)\n        : pic.url\n\n      if (to !== pic.url) {\n        movePaths.push({ from: pic.url, to })\n        setHolds.push(to)\n      }\n\n      toCreateNewPicturesData.push({\n        rank: index + 1,\n        url: to,\n      })\n    })\n\n    return {\n      toCreateNewPicturesData,\n      movePaths,\n      setHolds,\n      unsetHolds,\n    }\n  }\n\n  private manageVideoChanges(\n    productId: number,\n    viedos: ProductVideo[],\n    newVideos?: Pick<ProductVideo, 'rank' | 'url' | 'thumbnail'>[],\n  ) {\n    const oldVideos = viedos ?? []\n    const oldVideoUrls = oldVideos.map((vid) => vid.url)\n    const newVideoUrls = newVideos?.map((vid) => vid.url) ?? []\n\n    const toDeleteVideos = difference(oldVideoUrls, newVideoUrls)\n    const toCreateNewVideosData: Pick<\n      ProductVideo,\n      'rank' | 'url' | 'thumbnail'\n    >[] = []\n    const movePaths: { from: string; to: string }[] = []\n    const setHolds: string[] = []\n    const unsetHolds: string[] = []\n\n    newVideos?.forEach((vid, index) => {\n      if (!vid) return\n\n      const to = getMovePath(vid.url, `product/product/${productId}/video`)\n      const thumbnailTo = getMovePath(\n        vid.thumbnail,\n        `product/product/${productId}/video`,\n      )\n\n      if (!oldVideoUrls.includes(vid.url)) {\n        movePaths.push({ from: vid.url, to })\n        movePaths.push({ from: vid.thumbnail, to: thumbnailTo })\n      }\n\n      setHolds.push(to, thumbnailTo)\n\n      toCreateNewVideosData.push({\n        rank: index + 1,\n        url: to,\n        thumbnail: thumbnailTo,\n      })\n    })\n\n    toDeleteVideos.forEach((vid) => {\n      const video = oldVideos.find((v) => v.url === vid)\n      if (video) {\n        unsetHolds.push(video.url, video.thumbnail)\n      }\n    })\n\n    return {\n      toCreateNewVideosData,\n      movePaths,\n      setHolds,\n      unsetHolds,\n    }\n  }\n\n  private async processMediaFileOperations(mediaChanges: {\n    pictures: ReturnType<ProductService['managePictureChanges']>\n    videos: ReturnType<ProductService['manageVideoChanges']>\n  }) {\n    const unsetHolds = [\n      ...mediaChanges.pictures.unsetHolds,\n      ...mediaChanges.videos.unsetHolds,\n    ]\n\n    const movePaths = [\n      ...mediaChanges.pictures.movePaths,\n      ...mediaChanges.videos.movePaths,\n    ]\n\n    await fileService.unsetHoldObjects(unsetHolds)\n    await Promise.all(\n      movePaths.map((path) => fileService.moveObject(path.from, path.to)),\n    )\n  }\n\n  private async createProductMedia(\n    productId: number,\n    pictures: ProductPicture[],\n    videos: ProductVideo[],\n  ) {\n    const createdPictures = pictures\n    const createdVideos = videos\n    const setHolds = []\n    const movePaths = []\n    const updateProductPictures = []\n    const updateProductVideos = []\n    if (createdPictures.length) {\n      for (const picture of createdPictures) {\n        const to = getMovePath(\n          picture.url,\n          `product/product/${productId}/pictures`,\n        )\n        updateProductPictures.push({\n          rank: picture.rank,\n          url: to,\n        })\n        setHolds.push(to)\n        movePaths.push({ from: picture.url, to })\n      }\n    }\n    if (createdPictures.length) {\n      for (const video of createdVideos) {\n        const to = getMovePath(video.url, `product/product/${productId}/video`)\n        const thumbnailTo = getMovePath(\n          video.thumbnail,\n          `product/product/${productId}/video`,\n        )\n        updateProductVideos.push({\n          rank: video.rank,\n          url: to,\n          thumbnail: thumbnailTo,\n        })\n        setHolds.push(to)\n        setHolds.push(thumbnailTo)\n        movePaths.push({ from: video.url, to })\n        movePaths.push({ from: video.thumbnail, to: thumbnailTo })\n      }\n    }\n    if (movePaths.length) {\n      await Promise.all(\n        movePaths.map((path) => fileService.moveObject(path.from, path.to)),\n      )\n    }\n    if (setHolds.length) {\n      await fileService.setHoldObjects(setHolds)\n    }\n\n    return { updateProductPictures, updateProductVideos }\n  }\n\n  private async transformProductMedia(\n    pictures: ProductPictureInput[],\n    videos?: ProductVideoInput[],\n  ) {\n    const transformProductPictures = []\n    let pictureRank = 1\n\n    for (const picture of pictures) {\n      if (picture && !(await fileService.checkFileExist(picture.gsPath))) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: `Picture doesn't exist`,\n        })\n      } else {\n        transformProductPictures.push({\n          rank: pictureRank,\n          url: picture.gsPath,\n        })\n      }\n      pictureRank++\n    }\n\n    const transformProductVideos = []\n    if (videos && videos.length) {\n      let rank = 1\n\n      for (const video of videos) {\n        if (\n          video &&\n          !(await fileService.checkFileExist(video.gsPath)) &&\n          !(await fileService.checkFileExist(video.thumbnailGsPath))\n        ) {\n          throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: `Video doesn't exist`,\n          })\n        } else {\n          transformProductVideos.push({\n            rank: rank,\n            url: video.gsPath,\n            thumbnail: video.thumbnailGsPath,\n          })\n        }\n        rank++\n      }\n    }\n\n    return { transformProductPictures, transformProductVideos }\n  }\n\n  async createProductWithCustomFields(\n    createProductWithCustomFieldInput: ProductWithCustomFieldInputUnion,\n  ): Promise<ProductWithCustomFieldResponse> {\n    const { pictures, videos, ...productWithCustomField } =\n      createProductWithCustomFieldInput\n\n    // Sanitize input to remove omitted fields\n    const sanitizedProductWithCustomField = omit(productWithCustomField, [\n      'auxiliaryLabel',\n      'productForms',\n      'skinTypes',\n      'concerns',\n      'attribute',\n    ])\n\n    const { transformProductPictures, transformProductVideos } =\n      await this.transformProductMedia(pictures, videos)\n\n    const createdProduct =\n      await this.productRepository.createProductWithCustomFields({\n        ...sanitizedProductWithCustomField,\n        pictures: transformProductPictures,\n        videos: transformProductVideos,\n      })\n\n    const { updateProductPictures, updateProductVideos } =\n      await this.createProductMedia(\n        createdProduct.id,\n        createdProduct.pictures,\n        createdProduct.video,\n      )\n\n    const updatedProduct =\n      await this.productRepository.updateProductPicturesAndVideos(\n        createdProduct.id,\n        {\n          pictures: updateProductPictures,\n          videos: updateProductVideos,\n        },\n      )\n\n    await ProductPublisher.createProducts([updatedProduct.id])\n    return this.productWithCustomFieldResponseDTO(updatedProduct)\n  }\n\n  async updateProductWithCustomIds(\n    productId: number,\n    updateProductWithCustomFieldInput: Omit<\n      UpdateProductWithCustomFieldInputUnion,\n      'productId'\n    >,\n  ): Promise<ProductWithCustomFieldResponse> {\n    const { pictures, videos, ...productWithCustomField } =\n      updateProductWithCustomFieldInput\n\n    const product = await this.productRepository.getProductWithCustomFields(\n      productId,\n    )\n\n    if (!product) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Product not found',\n      })\n    }\n\n    // Sanitize input to remove omitted fields\n    const sanitizedProductWithCustomField = omit(productWithCustomField, [\n      'auxiliaryLabel',\n      'productForms',\n      'skinTypes',\n      'concerns',\n      'attribute',\n    ])\n\n    const { transformProductPictures, transformProductVideos } =\n      await this.transformProductMedia(pictures, videos)\n\n    const mediaChanges = this.manageProductMediaChanges(product, {\n      transformProductPictures,\n      transformProductVideos,\n    })\n\n    // Process file operations\n    await this.processMediaFileOperations(mediaChanges)\n\n    const updatedProduct =\n      await this.productRepository.updateProductWithCustomFields(productId, {\n        ...sanitizedProductWithCustomField,\n        pictures: mediaChanges.pictures.toCreateNewPicturesData,\n        videos: mediaChanges.videos.toCreateNewVideosData,\n      })\n\n    await ProductPublisher.updateProducts([updatedProduct.id])\n    return this.productWithCustomFieldResponseDTO(updatedProduct)\n  }\n\n  async getProductWithCustomFields(\n    productId: number,\n  ): Promise<ProductWithCustomFieldResponse> {\n    const productWithCustomFields =\n      await this.productRepository.getProductWithCustomFields(productId)\n\n    if (!productWithCustomFields) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Product not found',\n      })\n    }\n\n    const productResp = this.productWithCustomFieldResponseDTO(\n      productWithCustomFields,\n    )\n\n    return productResp\n  }\n\n  async getProducts(\n    getProductsTRPCInput: GetProductsTRPCInput,\n  ): Promise<GetProductResponse> {\n    return this.productRepository.getProducts(\n      getProductsTRPCInput,\n    ) as Promise<GetProductResponse>\n  }\n\n  async getProductsWithBrandAndCategories(\n    getProductsTRPCInput: GetProductsTRPCInput,\n  ): Promise<GetProductWithBrandAndCategoriesResponse> {\n    const { products, count } = await this.productRepository.getProducts({\n      ...getProductsTRPCInput,\n      include: {\n        brand: true,\n        categories: {\n          include: {\n            category: true,\n          },\n        },\n      },\n    })\n\n    return {\n      products: products.map((product) => ({\n        ...product,\n        categories: product.categories.map((item) => item.category),\n      })) as ProductWithBrandAndCategoriesResponse[],\n      count,\n    }\n  }\n\n  private productWithCustomFieldResponseDTO(\n    productWithCustomFieldResponseDTO: Awaited<\n      ReturnType<ProductRepository['getProductWithCustomFields']>\n    >,\n  ): ProductWithCustomFieldResponse {\n    const {\n      productOnCustomField,\n      brand,\n      categories,\n      variants,\n      pictures,\n      video,\n      ...product\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    } = productWithCustomFieldResponseDTO!\n\n    const customFieldsMap = new Map()\n    productOnCustomField.forEach((productCustomField) => {\n      const customFieldType = productCustomField.field.fieldType\n      const customField = productCustomField.field\n\n      const current = customFieldsMap.get(customFieldType) ?? []\n      current.push(customField)\n      customFieldsMap.set(customFieldType, current)\n    })\n\n    return {\n      ...product,\n      nameTr: product.nameTr as TrField,\n      descriptionTr: product.descriptionTr as TrFieldOptional,\n      instructionTr: product.instructionTr as TrFieldOptional,\n      sideEffectTr: product.sideEffectTr as TrFieldOptional,\n      cautionTr: product.cautionTr as TrFieldOptional,\n      propertyTr: product.propertyTr as TrFieldOptional,\n      genericTr: product.genericTr as TrFieldOptional,\n      brand: brand,\n      categories: categories.map(\n        (productCategory) => productCategory.category,\n      ) as never,\n      variants: variants,\n      videos: video,\n      pictures: pictures,\n      customFields: {\n        auxiliaryLabel: customFieldsMap.get('AUXILIARY_LABEL') ?? [],\n        drugClassification: customFieldsMap.get('DRUG_CLASSIFICATION') ?? [],\n        productForms: customFieldsMap.get('PRODUCT_FORMS') ?? [],\n        skinType: customFieldsMap.get('SKIN_TYPE') ?? [],\n        concerns: customFieldsMap.get('CONCERNS') ?? [],\n        attributes: customFieldsMap.get('ATTRIBUTES') ?? [],\n        productUsage: customFieldsMap.get('PRODUCT_USAGE') ?? [],\n        productUsageUnit: customFieldsMap.get('PRODUCT_USAGE_UNIT') ?? [],\n        productUsageFrequency:\n          customFieldsMap.get('PRODUCT_USAGE_FREQUENCY') ?? [],\n      },\n    }\n  }\n\n  async generateUploadProductMedia(\n    generateUploadProductMediaInput: GenerateUploadProductMediaInput,\n  ) {\n    const { extension, fieldPath } = generateUploadProductMediaInput\n\n    const contentType = mime.types[extension.toLowerCase()]\n    if (!contentType) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: `Invalid extension`,\n      })\n    }\n    const filename = uuidv4() + '.' + extension.toLowerCase()\n    const upload = await fileService.getUploadUrl(\n      path.join(`product/product/temp/`, fieldPath.replace('..', ''), filename),\n      contentType,\n    )\n    const viewUrl = fileService.getImageKitUrl(upload.gsPath)\n    return {\n      ...upload,\n      viewUrl,\n    }\n  }\n\n  async setActive(setActiveInput: ToggleProductActiveStatus) {\n    const { productId, active } = setActiveInput\n\n    const product = await this.productRepository.getProductWithVaraintsById(\n      productId,\n    )\n    const variants = product?.variants\n\n    if (!product) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Product not found',\n      })\n    }\n\n    if (active) {\n      if (!variants?.length) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'Please create variant before activate.',\n        })\n      }\n\n      if (variants.every((v) => !v.active)) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: 'Please activate at least one variant.',\n        })\n      }\n    }\n\n    const updatedProductActive = await this.productRepository.setActive(\n      setActiveInput,\n    )\n\n    await ProductPublisher.updateProducts([updatedProductActive.id])\n\n    return updatedProductActive\n  }\n\n  async setSearchable(setSearchableInput: ToggleProductSearchableStatus) {\n    const product = await this.productRepository.getProductById(\n      setSearchableInput.productId,\n    )\n\n    if (!product) {\n      throw new TRPCError({\n        code: 'NOT_FOUND',\n        message: 'Product not found',\n      })\n    }\n\n    const updatedProductSearchable = await this.productRepository.setSearchable(\n      setSearchableInput,\n    )\n\n    await ProductPublisher.updateProducts([updatedProductSearchable.id])\n\n    return updatedProductSearchable\n  }\n}\n\nexport default ProductService\n```\n\n\nBased on the service implementation, I'll help you create a mock input object for `createProductWithCustomFields`. Here's a comprehensive mock input:\n\n```typescript\nconst mockProductInput = {\n  // Required fields\n  nameTr: { en: 'Test Product', th: 'ผลิตภัณฑ์ทดสอบ' },\n  brandId: 1,\n  \n  // Optional translation fields\n  descriptionTr: { en: 'Product description', th: 'รายละเอียดผลิตภัณฑ์' },\n  instructionTr: { en: 'Usage instruction', th: 'วิธีใช้' },\n  sideEffectTr: { en: 'Side effects', th: 'ผลข้างเคียง' },\n  cautionTr: { en: 'Cautions', th: 'ข้อควรระวัง' },\n  propertyTr: { en: 'Properties', th: 'คุณสมบัติ' },\n  genericTr: { en: 'Generic name', th: 'ชื่อสามัญ' },\n\n  // Media fields\n  pictures: [\n    {\n      gsPath: 'test/path/image1.jpg',\n      rank: 1\n    },\n    {\n      gsPath: 'test/path/image2.jpg',\n      rank: 2\n    }\n  ],\n  videos: [\n    {\n      gsPath: 'test/path/video1.mp4',\n      thumbnailGsPath: 'test/path/thumb1.jpg',\n      rank: 1\n    }\n  ],\n\n  // Category and custom field associations\n  categoryId: [1, 2], // Array of category IDs\n  customFieldIds: [1, 2, 3], // Array of custom field IDs\n\n  // Other product details\n  type: 'MEDICINE',\n  drugGroup: 'OTC',\n  active: true,\n  searchable: true,\n  genericSearch: 'generic search terms',\n  searchField: 'search field terms',\n  \n  // Optional fields that will be omitted in sanitization\n  auxiliaryLabel: [],\n  productForms: [],\n  skinTypes: [],\n  concerns: [],\n  attribute: [],\n}\n```\n\nYou can use this in your test like this:\n\n```typescript\ndescribe('createProductWithCustomFields', () => {\n  const mockProductInput = {\n    // ... paste the mock input object here ...\n  }\n\n  it('should create a product with media successfully', async () => {\n    // Mock file checks\n    (fileService.checkFileExist as jest.Mock).mockResolvedValue(true)\n    \n    // Mock repository calls with appropriate return value\n    productRepository.createProductWithCustomFields.mockResolvedValue({\n      id: 1,\n      ...mockProductInput,\n      pictures: mockProductInput.pictures.map(pic => ({\n        productId: 1,\n        url: pic.gsPath,\n        rank: pic.rank\n      })),\n      video: mockProductInput.videos.map(vid => ({\n        productId: 1,\n        url: vid.gsPath,\n        thumbnail: vid.thumbnailGsPath,\n        rank: vid.rank\n      })),\n      // Add other required fields from the repository response\n      productOnCustomField: [],\n      categories: [],\n      brand: { id: 1, name: 'Test Brand' },\n      variants: []\n    })\n\n    const result = await productService.createProductWithCustomFields(mockProductInput)\n    \n    expect(result).toBeDefined()\n    expect(result.nameTr).toEqual(mockProductInput.nameTr)\n    expect(ProductPublisher.createProducts).toHaveBeenCalledWith([1])\n  })\n})\n```\n\nThis mock input includes all the necessary fields that the service expects and handles in the `createProductWithCustomFields` method. The fields that are meant to be omitted (`auxiliaryLabel`, `productForms`, `skinTypes`, `concerns`, `attribute`) are included but will be removed by the `omit` function in the service implementation.\n\nRemember to adjust the values according to your specific test cases and validation requirements.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":178}}},{"id":{"replica_id":0,"value":42},"start":10619,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":179}}},{"id":{"replica_id":0,"value":43},"start":13518,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":180}}},{"id":{"replica_id":0,"value":138},"start":30346,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":181}}},{"id":{"replica_id":0,"value":139},"start":33692,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":182}}}],"summary":"Mock Product Repository Test Values","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2,"end":8103},"icon":"File","label":"ssch-backend/packages/products/src/repositories/product/Product.repository.ts","metadata":{"path":"ssch-backend/packages/products/src/repositories/product/Product.repository.ts"}},{"range":{"start":8104,"end":10553},"icon":"File","label":"ssch-backend/packages/products/src/service/__test__/product/Product.service.spec.ts","metadata":{"path":"ssch-backend/packages/products/src/service/__test__/product/Product.service.spec.ts"}},{"range":{"start":13599,"end":30344},"icon":"File","label":"ssch-backend/packages/products/src/service/product/Product.service.ts","metadata":{"path":"ssch-backend/packages/products/src/service/product/Product.service.ts"}}]}